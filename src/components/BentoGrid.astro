---
import Card from './Card.astro';

interface Props {
  items: any[];
}

const { items } = Astro.props;

// 1. Limpieza de datos
const cleanItems = items.map((item) => {
  const data = item.frontmatter || item.data || item; 
  return {
    ...data,
    slug: item.url || item.slug 
  };
});

// Clases Responsivas
const getResponsiveClass = (span: number, isFirst: boolean) => {
  // Clase base para Móvil (siempre 1 columna)
  const base = 'col-span-1';

  // Clases para Tablet (md)
  // Si es primero usa span 2, si no span 1
  const md = isFirst ? 'md:col-span-2' : 'md:col-span-1';

  // Clases para Escritorio (lg) 
  const lgSizes: Record<number, string> = { //Diccionario para mapear span a clase
    1: 'lg:col-span-1',
    2: 'lg:col-span-2',
    3: 'lg:col-span-3',
    4: 'lg:col-span-4',
  };

  // Si por error llega un span raro, usamos el 1 por defecto
  const lg = lgSizes[span] || 'lg:col-span-1';

  return `${base} ${md} ${lg}`;
};

// 3. Algoritmo "Caos Inteligente"
const getRandomLayout = (data: any[]) => {
  if (data.length === 0) return [];

  const processed = [];
  
  // El Primero siempre es el Hero (Span 4)
  processed.push({ ...data[0], span: 4 });

  // Procesar el resto mirando cuántos quedan para no dejar huecos
  let i = 1;
  while (i < data.length) {
    const remaining = data.length - i;
    let pattern: number[] = [];

    // --- LÓGICA DE FILA FINAL ---
    
    // CASO 1: Queda exactamente 1 item
    // (Excepción: Debe ser 4 para no dejar hueco, aunque rompa la regla de "solo el primero")
    if (remaining === 1) {
      pattern = [4];
    }

    // CASO 2: Quedan exactamente 2 items
    // Obligatorio: Usar patrón de 2 items que sumen 4 de ancho
    else if (remaining === 2) {
       const dice = Math.random();
       if (dice < 0.33) pattern = [2, 2];
       else if (dice < 0.66) pattern = [3, 1];
       else pattern = [1, 3];
    }

    // CASO 3: Quedan exactamente 3 items
    // Obligatorio: Usar patrón de 3 items que sumen 4 de ancho
    else if (remaining === 3) {
       const dice = Math.random();
       if (dice < 0.33) pattern = [1, 1, 2];
       else if (dice < 0.66) pattern = [1, 2, 1];
       else pattern = [2, 1, 1];
    }

    // CASO 4: Quedan 4 o más items
    // Aquí decidimos aleatoriamente si consumimos 2 o 3 items en esta fila
    else {
      // 50% de probabilidad de hacer una fila de 3 items, 50% de hacer una de 2
      const chooseThreeItems = Math.random() < 0.5;

      if (chooseThreeItems) {
        // Generamos fila de 3 items (Consumimos 3 del total)
        const dice = Math.random();
        if (dice < 0.33) pattern = [1, 1, 2];
        else if (dice < 0.66) pattern = [1, 2, 1];
        else pattern = [2, 1, 1];
      } else {
        // Generamos fila de 2 items (Consumimos 2 del total)
        const dice = Math.random();
        if (dice < 0.33) pattern = [2, 2];
        else if (dice < 0.66) pattern = [3, 1];
        else pattern = [1, 3];
      }
    }

    // Asignar el patrón elegido
    pattern.forEach((spanValue, index) => {
      // Verificación de seguridad por si el array se acaba inesperadamente
      if (data[i + index]) {
        processed.push({ ...data[i + index], span: spanValue });
      }
    });

    // Avanzamos el índice tantos pasos como items hayamos usado
    i += pattern.length;
  }

  return processed;
};

const bentoItems = getRandomLayout(cleanItems);
---

<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-3 w-full p-3 auto-rows-fr grid-flow-dense">
  {bentoItems.map((item, index) => (
    <Card
      {...item}
      span={item.span}
      class={getResponsiveClass(item.span, index === 0)}
    />
  ))}
</div>